{"meta":{"title":"ZZxのwarm blog","subtitle":"<script type=\"text/javascript\" src=\"https://api.lwl12.com/hitokoto/main/get?encode=js&charset=utf-8\"></script><div id=\"lwlhitokoto\"><script>lwlhitokoto()</script></div>","description":"明天，不是你想要就能有的。","author":11101001,"url":"11101001.com"},"pages":[{"title":"分类","date":"1940-10-24T02:26:18.955Z","updated":"2018-02-07T23:25:46.000Z","comments":true,"path":"categories/index.html","permalink":"11101001.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"1940-10-24T02:26:18.955Z","updated":"2018-02-07T23:50:10.000Z","comments":true,"path":"about/index.html","permalink":"11101001.com/about/index.html","excerpt":"","text":"其实我很好奇你是怎么找到这的quq我是GRYZ的OIER我超级菜完"},{"title":"标签","date":"1940-10-24T02:26:18.955Z","updated":"2018-02-07T23:26:12.000Z","comments":true,"path":"tags/index.html","permalink":"11101001.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CodeForces - 997C Sky Full of Stars","slug":"CodeForces-997C","date":"2018-07-08T15:22:59.000Z","updated":"2018-07-09T03:02:12.000Z","comments":true,"path":"2018/07/08/CodeForces-997C/","link":"","permalink":"11101001.com/2018/07/08/CodeForces-997C/","excerpt":"On one of the planets of Solar system, in Atmosphere University, many students are fans of bingo game.It is well known that one month on this planet consists of $n^2$days, so calendars, represented as square matrix$n$ by n are extremely popular.Weather conditions are even more unusual. Due to the unique composition of the atmosphere, when interacting with sunlight, every day sky takes one of three colors: blue, green or red.To play the bingo, you need to observe the sky for one month — after each day, its cell is painted with the color of the sky in that day, that is, blue, green or red.At the end of the month, students examine the calendar. If at least one row or column contains only cells of one color, that month is called lucky.Let’s call two colorings of calendar different, if at least one cell has different colors in them. It is easy to see that there are$3^{n * n}$different colorings. How much of them are lucky? Since this number can be quite large, print it modulo $998244353$.","text":"On one of the planets of Solar system, in Atmosphere University, many students are fans of bingo game.It is well known that one month on this planet consists of $n^2$days, so calendars, represented as square matrix$n$ by n are extremely popular.Weather conditions are even more unusual. Due to the unique composition of the atmosphere, when interacting with sunlight, every day sky takes one of three colors: blue, green or red.To play the bingo, you need to observe the sky for one month — after each day, its cell is painted with the color of the sky in that day, that is, blue, green or red.At the end of the month, students examine the calendar. If at least one row or column contains only cells of one color, that month is called lucky.Let’s call two colorings of calendar different, if at least one cell has different colors in them. It is easy to see that there are$3^{n * n}$different colorings. How much of them are lucky? Since this number can be quite large, print it modulo $998244353$. 题目链接CodeForces - 997C Sky Full of Stars 题解有空补一下套题题解Qwq，然而我只是pilpuQwq设 $f(i,j)$ 表示至少有i行j列一种颜色的方案数可以发现，当ij有相交时颜色只能为一种 那么对于$i=0 || j=0$ 时 $f(i,j) = C_n^i C_n^j3^{(n - i) *(n - j) + i + j}$ 否则$f(i,j) = C_n^i C_n^j3^{(n - i) * (n - j) + 1}$可以得到一种很显然的容斥方法对于第一种情况单独算，复杂度$nlogn$对于第二个式子，容斥是$n^2$的,推式子 $3\\sum_{i=1}^{n}\\sum_{j=1}^{n}{C_n^iC_n^j(-1)^{i+j+1}3^{(n-i)(n-j)}}$设 $T=3^{ij}$ 换元 $3^{(n - i)*(n - j)}$ 原式 $=3\\sum_{i = 0}^{n - 1}\\sum_{j = 0}^{n - 1}C_n^iC_n^j(-1)^{i + j - 1}3^{ij}$拆 $(-1)^{i + j + 1}$ $=3\\sum_{i = 0}^{n - 1}C_n^i(-1)^{i + 1}\\sum_{j = 0}^{n - 1}C_n^j(-3^i)^{j}$另 $T=(-3)^i$对于后面那部分二项式定理因式分解 $=3\\sum_{i = 0}^{n - 1} C_n^i (-1)^{i + 1} *[(1 + T)^n - T^n]$复杂变成了$nlogn$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt; using namespace std; #define int long long const int maxn = 1000007; const int mod = 998244353; int n,fac[maxn],inv[maxn]; int fstpow(int x,int y) &#123; x %= mod; int ret = 1; for(; y; y &gt;&gt;= 1,x = 1ll * x * x % mod) if(y &amp; 1) ret = 1ll * ret * x % mod; return ret; &#125; int calc(int x,int y) &#123; return 1ll * ((fac[x] * inv[y]) % mod) * (inv[x - y]) % mod; &#125; void get_inv() &#123; fac[0] = 1,inv[0] = 1; for(int i = 1;i &lt;= n;i++) &#123; fac[i] = 1ll * fac[i - 1] * i % mod; inv[i] = fstpow(fac[i],mod - 2); &#125; &#125; main() &#123; scanf(\"%I64d\",&amp;n); get_inv(); int ans1 = 0; for(int a,b,i = 1;i &lt;= n;i++) &#123; a = 1ll * calc(n,i) * fstpow(-1,i + 1) % mod; b = fstpow(3, (1ll * n * (n - i) + i) % (mod - 1)); ans1 = (ans1 + (1ll * a * b % mod)) % mod; &#125; ans1 = 2 * ans1 % mod; int ans2 = 0; for(int t,b,a,i = 0;i &lt; n;i++) &#123; a = 1ll * calc(n,i) * fstpow(-1,i + 1) % mod; t = mod - fstpow(3,i); b = (fstpow(t + 1,n) + mod - fstpow(t,n)) % mod; ans2 = (ans2 + (1ll * a * b) % mod) % mod; &#125; //int tmp = printf(\"%I64d\\n\",(((ans1 + 1ll * ans2 * 3) % mod) + mod) % mod); return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"11101001.com/categories/题解/"},{"name":"CodeForces","slug":"题解/CodeForces","permalink":"11101001.com/categories/题解/CodeForces/"}],"tags":[{"name":"数学","slug":"数学","permalink":"11101001.com/tags/数学/"},{"name":"组合数学","slug":"组合数学","permalink":"11101001.com/tags/组合数学/"}]},{"title":"四月是你の省选 - sdoi2018酱油鸡","slug":"sdoi2018游记","date":"2018-04-06T06:29:29.000Z","updated":"2018-06-03T22:43:16.000Z","comments":true,"path":"2018/04/06/sdoi2018游记/","link":"","permalink":"11101001.com/2018/04/06/sdoi2018游记/","excerpt":"游啊游啊游啊游","text":"游啊游啊游啊游ruand1被noip送滚粗啦，真是菜死四月是你の省选…","categories":[{"name":"大ZZ的日常","slug":"大ZZ的日常","permalink":"11101001.com/categories/大ZZ的日常/"}],"tags":[{"name":"说明","slug":"说明","permalink":"11101001.com/tags/说明/"}]},{"title":"bzoj 4816 [Sdoi2017]数字表格.md","slug":"bzoj4816 [Sdoi2017]数字表格","date":"2018-04-01T09:12:29.000Z","updated":"2018-04-01T10:53:34.000Z","comments":true,"path":"2018/04/01/bzoj4816 [Sdoi2017]数字表格/","link":"","permalink":"11101001.com/2018/04/01/bzoj4816 [Sdoi2017]数字表格/","excerpt":"","text":"题目链接bzoj4816: [Sdoi2017]数字表格 题解满满的反演的套路的味道 Ans= \\prod_{i=1}^{n} \\prod_{j=1}^{m} f[gcd(i,j)]常规操作枚举约数 \\prod_{d=1}^n\\prod_{i=1}^n\\prod_{j=1}^m gcd(i,j)==d\\ ?\\ f[gcd(i,j)]上面的式子可以化为 \\prod_{d=1}^{n}f[d]^{\\sum_{i=1}^{n}\\sum_{j=1}^{m}[gcd(i,j)==d]}对于右上角的式子 \\sum_{i=1}^{n}\\sum_{j=1}^{m}[gcd(i,j)==d]很眼熟…推下式子 =\\sum_{i=1}^{? \\dfrac{n}{d}?}\\sum_{j=1}^{?\\dfrac{m}{d}?}[gcd(i,j)==1]=\\sum_{i=1}^{min(\\dfrac{n}{d},\\dfrac{m}{d})} \\mu(i)\\sum_{i|p,p\\leq n/d }\\sum_{i|j,j\\leq m/d}1=\\sum_{i=1}^{n/d}\\mu(i)\\left \\lfloor \\frac{n}{id}\\right \\rfloor \\left \\lfloor\\frac{m}{id} \\right \\rfloor令$p=id$那么原式变成了 \\prod_{p=1}^{min(n,m)} \\prod_{d|p} f[d]^{\\left \\lfloor \\frac{n}{p} \\right \\rfloor \\left \\lfloor \\frac{m}{p} \\right \\rfloor \\mu(\\frac{p}{d})} = \\prod_{p=1}^{min(n,m)} (\\prod_{d|p} f[d]^{\\mu(\\frac{p}{d})})^{\\left \\lfloor \\frac{n}{p} \\right \\rfloor \\left \\lfloor \\frac{m}{p} \\right \\rfloor}对于每个$p$,令$F[p]=\\prod_{d|p} f[d]^{\\mu(\\frac{p}{d})}$,$F[p]$的值是固定的，用筛法求出$F[p]$，做前缀积，对与$\\left \\lfloor \\frac{n}{p} \\right \\rfloor \\left \\lfloor \\frac{m}{p} \\right \\rfloor$数论分块一下复杂度为$O((n+T\\sqrt{n})log(1e9+7))$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;algorithm&gt;const int maxn = 1000007;const int mod = 1e9+7;int f[maxn+7],invf[maxn+7],F[maxn+7];bool isprime[maxn+7];int mu[maxn+7],prime[maxn+7],num;int pow(int a,int p) &#123; int ret=1; for(;p;p&gt;&gt;=1,a=(1LL*a*a)%mod)&#123; if(p&amp;1) ret=(1LL*ret*a)%mod; &#125; return ret;&#125;void init() &#123; f[1]=1; for(int i=2;i&lt;maxn;++i) f[i]=(f[i-1]+f[i-2])%mod; for(int i=1;i&lt;maxn;++i) &#123; invf[i]=pow(f[i],mod-2)%mod; //printf(\"%d %d\\n\",invf[i],f[i]); &#125; isprime[1]=1;mu[1]=1;F[0]=F[1]=1; //printf(\"%d\\n\",mu[1]); for(int i=2;i&lt;=maxn-7;++i) &#123; F[i]=1; if(!isprime[i]) prime[++num]=i,mu[i]=-1; for(int j=1;j&lt;=num&amp;&amp;prime[j]*i&lt;=maxn-7;++j) &#123; isprime[i*prime[j]]=1; if(i%prime[j]==0) &#123;mu[i*prime[j]]=0;break;&#125; else mu[i*prime[j]]=-mu[i]; &#125; &#125; for(int i=1;i&lt;=maxn-7;++i) &#123; if(mu[i]==0)continue; for(int j=i;j&lt;=maxn-7;j+=i) &#123; if(mu[i]==1) F[j]=(1ll*F[j]*f[j/i])%mod; if(mu[i]==-1) F[j]=(1ll*F[j]*invf[j/i])%mod; &#125; &#125; for(int i=1;i&lt;=maxn-7;++i) F[i]=(1ll*F[i]*F[i-1])%mod;//,printf(\"%d\\n\",F[i]);&#125;int query(int a,int b) &#123; int n=std::min(a,b);long long ans=1; for(int nxt,i=1;i&lt;=n;i=nxt+1) &#123; nxt=std::min(a/(a/i),b/(b/i)); long long tmp=1ll*F[nxt]*pow(F[i-1],mod-2)%mod; ans=(1ll*ans*pow(tmp,1ll*(a/i)*(b/i)%(mod-1)))%mod; &#125; return (ans+mod)%mod;&#125;int main() &#123; //freopen(\"001.out\",\"w\",stdout); init(); int T;scanf(\"%d\",&amp;T); for(int a,b;T--;) &#123; scanf(\"%d%d\",&amp;a,&amp;b); printf(\"%d\\n\",query(a,b)); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"11101001.com/categories/题解/"},{"name":"bzoj","slug":"题解/bzoj","permalink":"11101001.com/categories/题解/bzoj/"}],"tags":[{"name":"数学","slug":"数学","permalink":"11101001.com/tags/数学/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"11101001.com/tags/莫比乌斯反演/"}]},{"title":"bzoj 4817 [Sdoi2017]树点涂色","slug":"bzoj4817[Sdoi2017]树点涂色","date":"2018-04-01T08:55:29.000Z","updated":"2018-04-01T11:10:44.000Z","comments":true,"path":"2018/04/01/bzoj4817[Sdoi2017]树点涂色/","link":"","permalink":"11101001.com/2018/04/01/bzoj4817[Sdoi2017]树点涂色/","excerpt":"","text":"题目链接bzoj4817: [Sdoi2017]树点涂色 题解数据结构…..大概很容易看出是道lct 然后弃疗操作1很想lct里面的access操作那么对于操作2设F[i]=i点到lct根路径上的splay数（也就是虚边数）+1那么对于操作2的(x,y)ans(x,y)=F[x]+F[y]-(F(lca(x,y)))+1;对于操作3的(x),就是在x的子树中取max，我们可以用dfs序+线段树维护考虑操作1对操作3的影响在access的时候，当一个边由虚变实，此时该边所连的深度大的点的颜色种类-1反之当一边由实变虚，此时该边所连的深度大的点的颜色种类+1trick:保存当前节点在树中最左儿子的编号用以修改区间(即left[])ps:中途电脑爆炸,然后重码QAQ，心态爆炸 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183/* * * 数据结构+LCT+SEG_TREE * */#include&lt;cstdio&gt;#include&lt;algorithm&gt;const int maxn = 100007;int n,m;struct node&#123; int v,next;&#125;edge[maxn&lt;&lt;1];int head[maxn],num;void Add_Edge(int u,int v) &#123; edge[++num].v=v;edge[num].next=head[u];head[u]=num;&#125;int idfn[maxn],ldfn[maxn],rdfn[maxn],f[maxn][20],dep[maxn];int cnt=0,fa[maxn];void dfs(int u,int F) &#123; idfn[ldfn[u]=++cnt]=u,f[u][0]=fa[u]=F; for(int i=head[u];i;i=edge[i].next) &#123; int v=edge[i].v; if(v!=F) dep[v]=dep[u]+1,dfs(v,u); &#125; rdfn[u]=cnt; return ;&#125;int LCA(int x,int y) &#123; if(dep[x]&lt;dep[y]) std::swap(x,y); for(int i=dep[x]-dep[y],j=0;i;i&gt;&gt;=1,++j) if(i&amp;1)x=f[x][j]; if(x==y) return x; for(int i=19;~i;--i) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i]; return f[x][0];&#125;class Segment_Tree &#123;#define lc x&lt;&lt;1#define rc x&lt;&lt;1|1 private : struct Node &#123; int max,tag; Node () : tag(0)&#123;&#125; &#125;; Node t[maxn&lt;&lt;2]; void update(int x) &#123; t[x].max=std::max(t[lc].max,t[rc].max); &#125; void push_down(int x) &#123; if(!t[x].tag)return; int k=t[x].tag; t[lc].max+=k; t[lc].tag+=k; t[rc].max+=k; t[rc].tag+=k; t[x].tag=0; return ; &#125; public : void build (int x,int l,int r) &#123; if(l==r) &#123; t[x].max=dep[idfn[l]]+1;return; &#125; int mid=l+r&gt;&gt;1; build(lc,l,mid); build(rc,mid+1,r); return update(x); &#125; void modify(int x,int l,int r,int L,int R,int w) &#123; if(L&lt;=l&amp;&amp;R&gt;=r) &#123; t[x].tag+=w;t[x].max+=w; return ; &#125; push_down(x); int mid=l+r&gt;&gt;1; if(mid&gt;=L) modify(lc,l,mid,L,R,w); if(mid&lt;R) modify(rc,mid+1,r,L,R,w); return update(x); &#125; int query(int x,int l,int r,int L,int R) &#123; if(L&lt;=l&amp;&amp;R&gt;=r) return t[x].max; push_down(x); int mid=l+r&gt;&gt;1,ans=0; if(mid&gt;=L) ans=std::max(ans,query(lc,l,mid,L,R)); if(mid&lt;R) ans=std::max(ans,query(rc,mid+1,r,L,R)); return ans; &#125;#undef lc#undef rc&#125;SEG_T;class Link_Cut_tree &#123;#define lc ch[x][0]#define rc ch[x][1] private : int ch[maxn][2],left[maxn]; void update(int x) &#123; left[x]=lc ? left[lc]:x; &#125; bool isroot(int x) &#123; return ch[fa[x]][0]!=x&amp;&amp;ch[fa[x]][1]!=x; &#125; void rotate(int x) &#123; int y=fa[x],z=fa[y],d=(ch[y][1]==x)^1; if(!isroot(y)) ch[z][ch[z][1]==y]=x;fa[x]=z; ch[y][d^1]=ch[x][d],fa[ch[x][d]]=y; ch[x][d]=y;fa[y]=x; update(y),update(x); &#125; void splay(int x) &#123; while(!isroot(x)) &#123; int y=fa[x],z=fa[y]; if(!isroot(y)) &#123; if(ch[y][1]==x^ch[z][1]==y) rotate(x); else rotate(y); &#125; rotate(x); &#125; &#125; public: void init() &#123; dfs(1,0),SEG_T.build(1,1,n); for(int i=1;i&lt;=n;++i) left[i]=i; for(int j=1;j&lt;20;j++) for(int i=1;i&lt;=n;i++) f[i][j]=f[f[i][j-1]][j-1]; &#125; void access(int x) &#123; for(int t=0;x;x=fa[t=x]) &#123; splay(x); if(rc) SEG_T.modify(1,1,n,ldfn[left[rc]],rdfn[left[rc]],1); rc=t; if(rc) SEG_T.modify(1,1,n,ldfn[left[rc]],rdfn[left[rc]],-1); &#125; return ; &#125; int query(int x) &#123; int ans=0; for(;x;x=fa[x],ans++)splay(x); return ans; &#125; int query(int u,int v) &#123; return query(u)+query(v)-2*query(LCA(u,v))+1; &#125;#undef lc#undef rc&#125;LCT;int main() &#123;// freopen(\"001.out\",\"w\",stdout); scanf(\"%d%d\",&amp;n,&amp;m) ; for(int a,b,i=1;i&lt;n;++i) &#123; scanf(\"%d%d\",&amp;a,&amp;b); Add_Edge(a,b); Add_Edge(b,a); &#125; LCT.init(); for(int opt,x,y,i=1;i&lt;=m;++i) &#123; scanf(\"%d\",&amp;opt); if(opt==1) scanf(\"%d\",&amp;x),LCT.access(x); if(opt==2) scanf(\"%d%d\",&amp;x,&amp;y),printf(\"%d\\n\",LCT.query(x,y)); else if(opt==3) scanf(\"%d\",&amp;x),printf(\"%d\\n\",SEG_T.query(1,1,n,ldfn[x],rdfn[x])); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"11101001.com/categories/题解/"},{"name":"bzoj","slug":"题解/bzoj","permalink":"11101001.com/categories/题解/bzoj/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"11101001.com/tags/数据结构/"},{"name":"Link cut tree","slug":"Link-cut-tree","permalink":"11101001.com/tags/Link-cut-tree/"}]},{"title":"bzoj 3994 [SDOI2015]约数个数和","slug":"bzoj3994[SDOI2015]约数个数和","date":"2018-03-11T05:12:29.000Z","updated":"2018-03-11T09:14:46.000Z","comments":true,"path":"2018/03/11/bzoj3994[SDOI2015]约数个数和/","link":"","permalink":"11101001.com/2018/03/11/bzoj3994[SDOI2015]约数个数和/","excerpt":"","text":"题目链接bzoj 3994: [SDOI2015]约数个数和 题解结论与结论的证明参考了rqy的博客计算$d(ij)$时，把ij的每个约数d映射到$(a=gcd(d,i),b=(gcd(d,i),\\frac{d}{gcd(d, i)})$可知$a,b$分别是$i,j$的因数，且$(a,b)$对应一个因数当且仅当$gcd(\\frac ia, b) = 1$，所以 d(ij) = \\sum_{x|i}\\sum_{y|j} [gcd(\\frac ix, y) = 1] = \\sum_{x'|i}\\sum_{y|j} [gcd(x', y) = 1]有了这个式子之后 \\sum_{i=1}^n\\sum_{j=1}^m d(ij)=\\sum_{i=1}^n\\sum_{j=1}^m\\sum_{x|i}\\sum_{y|j} [gcd(x, y) = 1]=\\sum_{i=1}^n\\sum_{j=1}^m \\left\\lfloor\\frac ni\\right\\rfloor \\left\\lfloor\\frac mj\\right\\rfloor [gcd(i, j) = 1]=\\sum_{i=1}^{n}\\sum_{j=1}^{m}\\sum_{d|i}\\sum_{d|j}\\mu(d)\\lfloor\\frac{n}{i}\\rfloor\\lfloor\\frac{m}{j}\\rfloor=\\sum_{d=1}^{min(n,m)}\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac{m}{d}\\rfloor}\\mu(d)\\lfloor\\frac{n}{i}\\rfloor\\lfloor\\frac{m}{j}\\rfloor=\\sum_{d=1}^{min(n,m)}\\mu(d)\\sum_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\lfloor\\frac{n}{i}\\rfloor\\sum_{j=1}^{\\lfloor\\frac{m}{d}\\rfloor}\\lfloor\\frac{m}{j}\\rfloor用$f(x)=\\sum_{i=1}^{x}\\lfloor\\frac{x}{i}\\rfloor$表示1-x的约数个数和 \\sum_{d=1}^{min(n,m)}\\mu(d)f(\\lfloor\\frac{n}{d}\\rfloor)f(\\lfloor\\frac{m}{d}\\rfloor)预处理$\\mu(n)$前缀和对于$f$我们可以$O(n\\sqrt n)$预处理,查询为$O(\\sqrt n)$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;const int maxn = 50007;#define int long longinline int read() &#123; int x=0,f=1; char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='0')f=-1;c=getchar();&#125; while(c&lt;='9'&amp;&amp;c&gt;='0')x=x*10+c-'0',c=getchar(); return x*f;&#125;int f[maxn],mu[maxn],num,prime[maxn];bool vis[maxn];inline int countf(int x) &#123; int ans=0; for(int i=1,last;i&lt;=x;i=last+1) &#123; last=x/(x/i); ans+=x/i*(last-i+1); &#125; return ans;&#125;void get_mu() &#123; mu[1]=1; for(int i=2;i&lt;maxn;++i) &#123; if(!vis[i])prime[++num]=i,mu[i]=-1; for(int j=1;j&lt;=num&amp;&amp;i*prime[j]&lt;maxn;++j) &#123; vis[prime[j]*i]=1; if(i%prime[j]==0)mu[prime[j]*i]=0; else mu[i*prime[j]]=-mu[i]; &#125; &#125; for(int i=1;i&lt;maxn;++i)mu[i]+=mu[i-1];&#125;void init() &#123; for(int i=1;i&lt;maxn;++i)f[i]=countf(i); get_mu();&#125;int solve(int n,int m) &#123; int ans=0; for(int i=1,last;i&lt;=std::min(n,m);i=last+1) &#123; last=std::min(n/(n/i),m/(m/i)); ans+=(mu[last]-mu[i-1])*f[n/i]*f[m/i]; &#125; return ans;&#125;main() &#123; init(); int T=read(); for(;T--;) &#123; printf(\"%lld\\n\",solve(read(),read())); &#125; int tmp=0; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"11101001.com/categories/题解/"},{"name":"bzoj","slug":"题解/bzoj","permalink":"11101001.com/categories/题解/bzoj/"}],"tags":[{"name":"数学","slug":"数学","permalink":"11101001.com/tags/数学/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"11101001.com/tags/莫比乌斯反演/"}]},{"title":"<置顶> 罪恶的伊始","slug":"总得有个说明吧QAQ","date":"2018-03-10T12:29:29.000Z","updated":"2018-06-03T22:44:32.000Z","comments":true,"path":"2018/03/10/总得有个说明吧QAQ/","link":"","permalink":"11101001.com/2018/03/10/总得有个说明吧QAQ/","excerpt":"","text":"GRYZ 60级在读学生最想的事情是 变得可爱 长高喜欢思考，然而这会使人变颓拉拉人，只厨$\\mu’s$不厨水团 \\滑稽 然后非常不要脸的留下QQ : 741623027可以交流问题的嘛然后就没有啦 upd:对了,我这人似乎tm有病 对了，这个博客是放题解的","categories":[{"name":"大ZZ的日常","slug":"大ZZ的日常","permalink":"11101001.com/categories/大ZZ的日常/"}],"tags":[{"name":"说明","slug":"说明","permalink":"11101001.com/tags/说明/"}]},{"title":"数列分块1-9","slug":"数列分块1-9","date":"2018-03-10T12:25:29.000Z","updated":"2018-03-10T13:32:44.000Z","comments":true,"path":"2018/03/10/数列分块1-9/","link":"","permalink":"11101001.com/2018/03/10/数列分块1-9/","excerpt":"","text":"数列分块1-9偷下懒QuQ 题目链接loj的数列分块如门1-9 这算是题解了吧题解的话我就不说了吧毕竟，黄学长的博客里已经说得很清楚了吧2333(我真是废QAQ………Hzwer传送门 代码数列分块112345678910111213141516171819202122232425262728293031#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;int n,m;inline int read() &#123; int x=0,f=1; char c=getchar(); while(c&lt;'0'||c&gt;'9') &#123;if(c=='0')f=-1;c=getchar();&#125; while(c&lt;='9'&amp;&amp;c&gt;='0')x=x*10+c-'0',c=getchar(); return x*f;&#125;const int maxn = 100007;int a[maxn],bl[maxn],tag[maxn],size;void modify(int aa,int b,int c) &#123; for(int i=aa;i&lt;=std::min(bl[aa]*size,b);++i) a[i]+=c; if(bl[aa]!=bl[b]) for(int i=(bl[b]-1)*size+1;i&lt;=b;++i)a[i]+=c; for(int i=bl[aa]+1;i&lt;=bl[b]-1;++i) tag[i]+=c;&#125;int main() &#123; n=read(),size=sqrt(n); for(int i=1;i&lt;=n;++i) a[i]=read(); for(int i=1;i&lt;=n;++i) bl[i]=(i-1)/size+1; for(int op,aa,b,c,i=1;i&lt;=n;++i) &#123; op=read(),aa=read(),b=read(),c=read(); if(!op)modify(aa,b,c); else printf(\"%d\\n\",a[b]+tag[bl[b]]); &#125; return 0;&#125; 数列分块2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using std::vector;vector&lt;int&gt;vec[100086];int n,m;inline int read() &#123; int x=0,f=1; char c=getchar(); while(c&lt;'0'||c&gt;'9') &#123;if(c=='0')f=-1;c=getchar();&#125; while(c&lt;='9'&amp;&amp;c&gt;='0')x=x*10+c-'0',c=getchar(); return x*f;&#125;const int maxn = 100007;int a[maxn],bl[maxn],tag[maxn],size;void update(int x) &#123; vec[x].clear(); for(int i=(x-1)*size+1;i&lt;=std::min(x*size,n);++i) vec[x].push_back(a[i]); std::sort(vec[x].begin(),vec[x].end());&#125;void modify(int aa,int b,int c) &#123; for(int i=aa;i&lt;=std::min(bl[aa]*size,b);++i) a[i]+=c; update(bl[aa]); if(bl[aa]!=bl[b]) &#123; for(int i=(bl[b]-1)*size+1;i&lt;=b;++i)a[i]+=c; update(bl[b]); &#125; for(int i=bl[aa]+1;i&lt;=bl[b]-1;++i) tag[i]+=c;&#125;int query(int aa,int b,int c) &#123; int ans=0;c*=c; for(int i=aa;i&lt;=std::min(b,bl[aa]*size);++i) if(a[i]+tag[bl[aa]]&lt;c)ans++; if(bl[aa]!=bl[b]) for(int i=(bl[b]-1)*size+1;i&lt;=b;++i) if(a[i]+tag[bl[b]]&lt;c)ans++; for(int i=bl[aa]+1;i&lt;=bl[b]-1;++i) &#123; int x=c-tag[i]; ans+=lower_bound(vec[i].begin(),vec[i].end(),x)-vec[i].begin(); &#125; return ans;&#125;int main() &#123; n=read(),size=sqrt(n); for(int i=1;i&lt;=n;++i) a[i]=read(); for(int i=1;i&lt;=n;++i) bl[i]=((i-1)/size+1),vec[bl[i]].push_back(a[i]); for(int i=1;i&lt;=bl[n];i++)std::sort(vec[i].begin(),vec[i].end()); for(int op,aa,b,c,i=1;i&lt;=n;++i) &#123; op=read(),aa=read(),b=read(),c=read(); if(!op)modify(aa,b,c); else printf(\"%d\\n\",query(aa,b,c)); &#125; return 0;&#125; 数列分块312345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using std::vector;vector&lt;int&gt;vec[100086];int n,m;inline int read() &#123; int x=0,f=1; char c=getchar(); while(c&lt;'0'||c&gt;'9') &#123;if(c=='0')f=-1;c=getchar();&#125; while(c&lt;='9'&amp;&amp;c&gt;='0')x=x*10+c-'0',c=getchar(); return x*f;&#125;const int maxn = 100007;int a[maxn],bl[maxn],tag[maxn],size;void update(int x) &#123; vec[x].clear(); for(int i=(x-1)*size+1;i&lt;=std::min(x*size,n);++i) vec[x].push_back(a[i]); std::sort(vec[x].begin(),vec[x].end());&#125;void modify(int aa,int b,int c) &#123; for(int i=aa;i&lt;=std::min(bl[aa]*size,b);++i) a[i]+=c; update(bl[aa]); if(bl[aa]!=bl[b]) &#123; for(int i=(bl[b]-1)*size+1;i&lt;=b;++i)a[i]+=c; update(bl[b]); &#125; for(int i=bl[aa]+1;i&lt;=bl[b]-1;++i) tag[i]+=c;&#125;int query(int aa,int b,int c) &#123; int tmp,ret=-1,retc=0x3f3f3f3f; for(int i=aa;i&lt;=std::min(b,bl[aa]*size);++i) if(c&gt;a[i]+tag[bl[aa]]) &#123; tmp=(c-(a[i]+tag[bl[aa]])); if(tmp&lt;retc) retc=tmp,ret=a[i]+tag[bl[aa]]; &#125; //if(a[i]+tag[bl[aa]]&gt;=c)return a[i-1]; if(bl[aa]!=bl[b]) for(int i=(bl[b]-1)*size+1;i&lt;=b;++i) if(c&gt;a[i]+tag[bl[b]]) &#123; tmp=(c-(a[i]+tag[bl[b]])); if(tmp&lt;retc) retc=tmp,ret=a[i]+tag[bl[b]]; &#125; for(int i=bl[aa]+1;i&lt;=bl[b]-1;++i) &#123; int x=c-tag[i]; int loc=lower_bound(vec[i].begin(),vec[i].end(),x)-vec[i].begin()-1; if(loc&lt;0)continue; tmp=c-vec[i][loc]-tag[i]; if(tmp&lt;retc) retc=tmp,ret=vec[i][loc]+tag[i]; &#125; return ret;&#125;int main() &#123; //std::cin&gt;&gt;a;std::cout&lt;&lt;a; n=read(),size=sqrt(n); for(int i=1;i&lt;=n;++i) a[i]=read(); for(int i=1;i&lt;=n;++i) bl[i]=((i-1)/size+1),vec[bl[i]].push_back(a[i]); for(int i=1;i&lt;=bl[n];i++)std::sort(vec[i].begin(),vec[i].end()); for(int op,aa,b,c,i=1;i&lt;=n;++i) &#123; op=read(),aa=read(),b=read(),c=read(); if(!op)modify(aa,b,c); else printf(\"%d\\n\",query(aa,b,c)); &#125; return 0;&#125;/*6123 321 245 654 232 2331 2 5 2460 2 4 6661 1 6 888*/ 数列分块4123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;int n,m;inline int read() &#123; int x=0,f=1; char c=getchar(); while(c&lt;'0'||c&gt;'9') &#123;if(c=='0')f=-1;c=getchar();&#125; while(c&lt;='9'&amp;&amp;c&gt;='0')x=x*10+c-'0',c=getchar(); return x*f;&#125;const int maxn = 100007;long long a[maxn];int bl[maxn],size;long long tag[maxn],sum[maxn];void modify(int aa,int b,int c) &#123; for(int i=aa;i&lt;=std::min(bl[aa]*size,b);++i) a[i]+=c,sum[bl[i]]+=c;//,[bl[a]]+=c; if(bl[aa]!=bl[b]) for(int i=(bl[b]-1)*size+1;i&lt;=b;++i) a[i]+=c,sum[bl[i]]+=c;//,tag[bl[b]]+=c; for(int i=bl[aa]+1;i&lt;=bl[b]-1;++i) tag[i]+=c;&#125;long long query(int aa,int b,int c) &#123; long long ans=0; for(int i=aa;i&lt;=std::min(b,bl[aa]*size);++i) ans+=a[i]+tag[bl[aa]]; if(bl[aa]!=bl[b]) for(int i=(bl[b]-1)*size+1;i&lt;=b;++i) ans+=a[i]+tag[bl[b]]; for(int i=bl[aa]+1;i&lt;=bl[b]-1;++i) &#123; ans+=sum[i]+tag[i]*size; &#125; return ans%c;&#125;int main() &#123; //std::cin&gt;&gt;a;std::cout&lt;&lt;a; n=read(),size=sqrt(n); for(int i=1;i&lt;=n;++i) a[i]=read(); for(int i=1;i&lt;=n;++i) bl[i]=((i-1)/size+1),sum[bl[i]]+=a[i]; for(int op,aa,b,c,i=1;i&lt;=n;++i) &#123; op=read(),aa=read(),b=read(),c=read(); if(!op)modify(aa,b,c); else printf(\"%d\\n\",query(aa,b,c+1)); &#125; return 0;&#125;/*6123 321 245 654 232 2331 2 5 2460 2 4 6661 1 6 888*/ 数列分块512345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using std::min;inline int read() &#123; int x=0,op=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')op=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x*op;&#125;const int maxn = 100007;int n,size;int bl[maxn],a[maxn],sum[maxn],tag[maxn];inline void update(int x) &#123; if(tag[x])return; tag[x]=1,sum[x]=0; for(int i=(x-1)*size+1;i&lt;=x*size;i++) &#123; a[i]=sqrt(a[i]),sum[x]+=a[i]; if(a[i]&gt;1)tag[x]=0; &#125;&#125;void add(int l,int r) &#123; for(int i=l;i&lt;=min(bl[l]*size,r);i++) sum[bl[l]]-=a[i],a[i]=sqrt(a[i]),sum[bl[l]]+=a[i]; if(bl[l]!=bl[r]) for(int i=(bl[r]-1)*size+1;i&lt;=r;i++) sum[bl[r]]-=a[i],a[i]=sqrt(a[i]),sum[bl[r]]+=a[i]; for(int i=bl[l]+1;i&lt;=bl[r]-1;i++) update(i);&#125;int query(int l,int r) &#123; int ans=0; for(int i=l;i&lt;=min(bl[l]*size,r);i++) ans+=a[i]; if(bl[l]!=bl[r]) for(int i=(bl[r]-1)*size+1;i&lt;=r;i++) ans+=a[i]; for(int i=bl[l]+1;i&lt;=bl[r]-1;i++) ans+=sum[i]; return ans;&#125;int main() &#123; n=read();size=sqrt(n); for(int i=1;i&lt;=n;i++)a[i]=read(); for(int i=1;i&lt;=n;i++) bl[i]=(i-1)/size+1,sum[bl[i]]+=a[i]; for(int op,a,b,c,i=1;i&lt;=n;i++) &#123; op=read(),a=read(),b=read(),c=read(); if(!op)add(a,b); else printf(\"%d\\n\",query(a,b)); &#125; return 0;&#125; 数列分块6123456789101112131415161718192021222324252627282930313233343536#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using std::vector;const int maxn = 100007;inline int read() &#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9') &#123;if(c=='-')f=-1;c=getchar();&#125; while(c&lt;='9'&amp;&amp;c&gt;='0') x=x*10+c-'0',c=getchar(); return x*f;&#125;vector&lt;int&gt;vec[maxn];int a[maxn],bl[maxn],size,n;void insert(int loc,int w) &#123; for(int i=1;i&lt;=bl[n];++i) &#123; if(loc&lt;=vec[i].size()) &#123;vec[i].insert(vec[i].begin()+loc-1,w);return;&#125; loc-=vec[i].size(); &#125;&#125;int query(int loc) &#123; for(int i=1;i&lt;=bl[n];++i) &#123; if(loc&lt;=vec[i].size()) return vec[i][loc-1]; loc-=vec[i].size(); &#125;&#125;int main() &#123; n=read();size=sqrt(n); for(int i=1;i&lt;=n;++i)a[i]=read(); for(int i=1;i&lt;=n;++i)bl[i]=(i-1)/size+1,vec[bl[i]].push_back(a[i]); for(int op,aa,b,c,i=1;i&lt;=n;++i) &#123; op=read(),aa=read(),b=read(),c=read(); if(!op) insert(aa,b); else printf(\"%d\\n\",query(b)); &#125;&#125; 数列分块7123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define mod 10007using std::min;const int maxn = 100007;inline int read() &#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9') &#123;if(c=='-')f=-1;c=getchar();&#125; while(c&lt;='9'&amp;&amp;c&gt;='0') x=x*10+c-'0',c=getchar(); return x*f;&#125;int tagm[maxn],taga[maxn];int a[maxn],bl[maxn],size,n;void reset(int x) &#123; for(int i=(x-1)*size+1;i&lt;=min(n,x*size);i++) a[i]=(a[i]*tagm[x]+taga[x])%mod; taga[x]=0;tagm[x]=1;&#125;void Modify_Add(int l,int r,int w) &#123; reset(bl[l]); for(int i=l;i&lt;=min(r,bl[l]*size);++i) a[i]+=w,a[i]%=mod; if(bl[l]!=bl[r]) &#123; reset(bl[r]); for(int i=(bl[r]-1)*size+1;i&lt;=r;++i) a[i]+=w,a[i]%=mod; &#125; for(int i=bl[l]+1;i&lt;=bl[r]-1;++i) taga[i]+=w,taga[i]%=mod;&#125;void Modify_Mul(int l,int r,int w) &#123; reset(bl[l]); for(int i=l;i&lt;=min(bl[l]*size,r);++i) a[i]*=w,a[i]%=mod; if(bl[l]!=bl[r]) &#123; reset(bl[r]); for(int i=(bl[r]-1)*size+1;i&lt;=r;++i) a[i]*=w,a[i]%=mod; &#125; for(int i=bl[l]+1;i&lt;=bl[r]-1;++i) tagm[i]=tagm[i]*w%mod,taga[i]=taga[i]*w%mod;&#125;int main() &#123; n=read();size=sqrt(n); for(int i=1;i&lt;=n;++i)a[i]=read(),tagm[i]=1;tagm[n+1]=1; for(int i=1;i&lt;=n;++i)bl[i]=(i-1)/size+1; for(int op,aa,b,c,i=1;i&lt;=n;++i) &#123; op=read(),aa=read(),b=read(),c=read()%mod; if(!op) Modify_Add(aa,b,c); else if(op==1)Modify_Mul(aa,b,c); else printf(\"%d\\n\",(a[b]*tagm[bl[b]]+taga[bl[b]])%mod); &#125; return 0;&#125; 数列分块812345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using std::min;const int maxn = 100007;inline int read() &#123; int x=0,f=1; char c=getchar(); while(c&lt;'0'||c&gt;'9') &#123; if(c=='-')f=-1; c=getchar(); &#125;while(c&lt;='9'&amp;&amp;c&gt;='0') x=x*10+c-'0',c=getchar(); return x*f;&#125;int n,a[maxn],bl[maxn],tag[maxn],ans=0,size;void solve(int l,int r,int c) &#123; ans=0; if(tag[bl[l]]!=-1) &#123; for(int i=(bl[l]-1)*size+1;i&lt;=bl[l]*size;++i) a[i]=tag[bl[l]]; tag[bl[l]]=-1; &#125; for(int i=l;i&lt;=min(bl[l]*size,r);++i) ans+=a[i]==c,a[i]=c; //tag[bl[r]]=-1; if(bl[l]!=bl[r]) &#123; if(tag[bl[r]]!=-1) &#123; for(int i=(bl[r]-1)*size+1;i&lt;=bl[r]*size;++i) a[i]=tag[bl[r]]; tag[bl[r]]=-1; &#125; for(int i=(bl[r]-1)*size+1;i&lt;=r;++i) ans+=a[i]==c,a[i]=c; &#125; for(int i=bl[l]+1;i&lt;=bl[r]-1;++i) &#123; if(tag[i]==c)ans+=size; else if(tag[i]==-1) &#123; for(int j=(i-1)*size+1;j&lt;=i*size;++j) ans+=a[j]==c,a[j]=c; tag[i]=c; &#125; else tag[i]=c; &#125; printf(\"%d\\n\",ans);&#125;int main() &#123; n=read();size=sqrt(n); memset(tag,-1,sizeof tag); for(int i=1;i&lt;=n;++i)a[i]=read(); for(int i=1;i&lt;=n;++i)bl[i]=(i-1)/size+1; for(int aa,b,c,i=1;i&lt;=n;++i) &#123; aa=read(),b=read(),c=read(); solve(aa,b,c); &#125; return 0;&#125; 数列分块912345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;map&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using std::map;using std::vector;inline int read() &#123; int x=0,f=1; char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x*f;&#125;const int maxn = 110007;int v[maxn],val[maxn];int n,size,bl[maxn],id=0,atmp[671][671],cnt[10086];vector&lt;int&gt;vec[1007];map&lt;int,int&gt;mp;void build(int x) &#123; memset(cnt,0,sizeof cnt); int mcnt=0,mans=0; for(int i=(x-1)*size+1;i&lt;=n;++i) &#123; int vu=v[i]; cnt[vu]++; if(mcnt&lt;cnt[vu]||(mcnt==cnt[vu]&amp;&amp;val[vu]&lt;val[mans])) mans=vu,mcnt=cnt[vu]; atmp[x][bl[i]]=mans; &#125;&#125;inline int count(int a,int b,int mans) &#123; return upper_bound(vec[mans].begin(),vec[mans].end(),b)-lower_bound(vec[mans].begin(),vec[mans].end(),a);&#125;int query(int a,int b) &#123; int mans=atmp[bl[a]+1][bl[b]-1]; int mcnt=count(a,b,mans); for(int i=a;i&lt;=std::min(bl[a]*size,b);++i) &#123; int qcnt=count(a,b,v[i]);if(qcnt&gt;mcnt||(qcnt==mcnt&amp;&amp;val[v[i]]&lt;val[mans])) mcnt=qcnt,mans=v[i]; &#125; if(bl[a]!=bl[b]) for(int i=(bl[b]-1)*size;i&lt;=b;++i) &#123; int qcnt=count(a,b,v[i]);if(qcnt&gt;mcnt||(qcnt==mcnt&amp;&amp;val[v[i]]&lt;val[mans])) mcnt=qcnt,mans=v[i]; &#125; return val[mans];&#125; int main() &#123; n=read();size=sqrt(n); for(int i=1;i&lt;=n;++i) &#123; v[i]=read(); if(!mp[v[i]]) mp[v[i]]=++id,val[id]=v[i]; v[i]=mp[v[i]]; vec[v[i]].push_back(i); &#125; for(int i=1;i&lt;=n;++i) bl[i]=(i-1)/size+1; for(int i=1;i&lt;=bl[n];++i)build(i); for(int a,b,i=1;i&lt;=n;++i) &#123; a=read(),b=read(); if(a&gt;b)std::swap(a,b); printf(\"%d\\n\",query(a,b)); &#125; return 0;&#125; 完~","categories":[{"name":"题解","slug":"题解","permalink":"11101001.com/categories/题解/"},{"name":"loj","slug":"题解/loj","permalink":"11101001.com/categories/题解/loj/"}],"tags":[{"name":"题解","slug":"题解","permalink":"11101001.com/tags/题解/"},{"name":"分块","slug":"分块","permalink":"11101001.com/tags/分块/"}]},{"title":"博弈论与SG函数","slug":"博弈论与SG函数","date":"2018-02-28T11:58:14.000Z","updated":"2018-03-10T13:33:10.000Z","comments":true,"path":"2018/02/28/博弈论与SG函数/","link":"","permalink":"11101001.com/2018/02/28/博弈论与SG函数/","excerpt":"","text":"巴什博奕:两个顶尖聪明的人在玩游戏，有nn个石子，每人可以随便拿1−m1−m个石子，不能拿的人为败者，问谁会胜利 结论:设当前的石子数为$n=k∗(m+1)$即$n%(m+1)==0$时先手一定失败HDU1846123456789101112#include&lt;iostream&gt;using namespace std;int main() &#123; int C,N,M; scanf(\"%d\",&amp;C); while(C--) &#123; scanf(\"%d%d\",&amp;N,&amp;M); if(N%(M+1)==0) printf(\"second\\n\"); else printf(\"first\\n\"); &#125; return 0; &#125; HDU4764123456789101112#include&lt;cstdio&gt;#include&lt;algorithm&gt;const int MAXN=1e6+10,INF=1e9+10;int main() &#123; int x,y; while(scanf(\"%d%d\",&amp;x,&amp;y)) &#123; if(!x&amp;&amp;!y) break; if( (x-1)%(y+1)==0 ) puts(\"Jiang\\n\"); else puts(\"Tang\\n\"); &#125; return 0;&#125; nim游戏:有两个顶尖聪明的人在玩游戏有n堆石子，两个人可以从任意一堆石子中拿任意多个石子(不能不拿)，没法拿的人失败。问谁会胜利 结论:当$n$堆石子的数量异或和等于$0$时，先手必败，否则先手必胜 简证:定义当前状态为P-position：在当前的局面下，先手必败N-position：在当前的局面下，先手必胜对于面对局面为$0\\ xor\\ 0\\ xor\\ …\\ 0 = 0$称它为p局面 若当前局面为$a_1\\ xor\\ a_{2}\\ …a_n = k$ 来说我们可以通过改变一个$a_i$的比如$a_i\\ xor \\ k$值来使得上式的值为0,此时修改该操作的人为必败局面,由于$xor$计算的特殊性，我们知道一定有一个$a_i$最高位与$k$最高位的1是相同的，那么必然有$a_i\\ xor\\ k\\ &lt;a_i$的,所以操作可为减法 对于局面$a_1\\ xor\\ a_{2}\\ …a_n = 0$那么此时对于任何一种操作都会使得上式的值发生改变，也就是不为0对与xor的性质,当每个位置的1都存在偶数个时，异或和为0,只改变一个$a_i$,一定会使得某个位置的1的个数发生改变所以只有当先手面临$xor$和为0是，必胜luogu P2197 nim游戏12345678910111213141516171819#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;int main() &#123; int T; //scanf(\"%d\",&amp;T); std::cin&gt;&gt;T; for(int n;T--;) &#123; std::cin&gt;&gt;n; int tmp=0; for(int q,i=1;i&lt;=n;++i) &#123; std::cin&gt;&gt;q;tmp^=q; &#125; if(!tmp)puts(\"No\"); else puts(\"Yes\"); &#125; //char a[10];scanf(\"%s\",a);puts(a); return 0;&#125; SG函数SG函数内容的理解借鉴自zyf学长,鸣谢！QUQ对于nim游戏，你已经知道怎么做了但是，要是稍加改变游戏规则，那么恐怕无法很快找出必胜策略 我们可以吧游戏抽象为一张图，每一个点代表一个状态，对于每个状态与他的子状态连一条有向边。那么，我们在这张有向无环图上引入SG函数 定义定义运算$mex()$,这是对于一个集合的运算,表示最小的不属于该集合的非负整数例如$mex\\{0,1,2,3\\}=4;mex\\{2,3,5\\}=0$。那么对于每个顶点的SG值为:后继中未出现过的最小值 sg(x)=mex\\{sg(y)\\}y为x的后继 SG函数的性质首先对于出度为0的点，他的SG值为0对于一个SG值为0的点x，他的后继y都满足sg(y)!=0,y的后继中一定有存在一个点的SG值为0诶,是不是和刚才nim游戏很像所以当SG(x)=0时,x代表了p局面 扩展考虑有向图上有n个棋子,每次可以移动一颗,不能移动者lose,这时候怎样找到必胜策略呢?我们来考虑每个顶点的SG值得含义,当$sg(x)=k$时，x的后继y的$sg(y)=1\\ -&gt;\\ k$也就是说，某个棋子进行移动后sg值是一定会发生改变的类比普通的nim游戏,Nim游戏的一种必胜策略就是把$a_i$变为k,那么,把第i个棋子移动到一个SG值为k的点上就是一种必胜策略hhhh,也就是说Nim游戏的一种必胜策略对应着这n个棋子的必胜策略 那么这个游戏P局面就棋子所在位置的SG函数异或和为0的时候。 经典的博弈问题再来说一下几类经典的博弈问题 Anti-Nim游戏和SJ定理有两个顶尖聪明的人在玩游戏(他们一个是崩崩崩玩家一个是舰娘玩家),游戏规则是这样的：有n堆石子，两个人可以从任意一堆石子中拿任意多个石子(不能不拿)，拿走最后一个石子的人失败。问谁会胜利? 结论先手必胜当且仅当：所有堆的石子数都为1且游戏的SG值为0有些堆的石子数大于1且游戏的SG值不为0 证明1)游戏有三种情况 每堆只有一个石子 异或和为0先手必胜 异或和不为0先手必败2)只存在一堆石子数&gt;1,则先手必胜可以发现，在这种情况下异或值一定 ！= 0并且先手一定可以使剩下的奇数个石子变为个数为1的堆3)存在2堆以上的石子数&gt;1-异或和=0时先手必败-异或和!=0先手必胜那么考虑nim游戏，当异或和=0时,洗衣不操作都会使异或和！=0,相反同样….符合NP状态的转换不断进行转换会在一个时刻变为 ‘只有一堆大于1’ 的局面,而该局面一定是有 ‘两堆&gt;1且异或和=0’ 的局面 转来的,所以 ‘两堆&gt;1且异或和=0’ 的局面一定会在某一时刻转化为 ‘只有一堆大于1’ 的 先手必胜局面 ,也就是说是先手必败态;其他同理可证bzoj 1022: [SHOI2008]小约翰的游戏John 1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;algorithm&gt;inline int read() &#123; int x=0,f=1; char c=getchar() ; while(c&lt;'0'||c&gt;'9') &#123; if(c=='-')f=-1; c=getchar(); &#125; while(c&lt;='9'&amp;&amp;c&gt;='0')x=x*10+c-'0',c=getchar(); return x*f;&#125;int a;int main() &#123; for(int n,T=read();T--;) &#123; n=read();bool op=1;int tmp=0; for(int i=1;i&lt;=n;++i) &#123; a=read();if(a!=1)op=0; tmp^=a; &#125; if((op&amp;&amp;!tmp) || (!op&amp;&amp;tmp))puts(\"John\"); else puts(\"Brother\"); &#125; return 0;&#125; SJ定理定理：SJ定理 对于任意一个Anti-SG游戏，如果我们规定当局面中所有的单一游戏的SG值为0时，游戏结束，则先手必胜当且仅当： (1)游戏的SG函数不为0且游戏中某个单一游戏的SG函数大于 1; (2)游戏的SG函数为0且游戏中没有单一游戏的SG函数大于1。 Multi-SG有n堆石子，两个人可以从任意一堆石子中拿任意多个石子(不能不拿)或把一堆数量不少于2石子分为两堆不为空的石子，没法拿的人失败。问谁会胜利 分析用sg函数来解决操作1与nim游戏无异,对与一个石子数为k的点来说,后继可以为1..k操作二实际上是将一个游戏分解为两个游戏，根据SG定理，两个有的的和为两个游戏的SG函数值得异或，我们可以通过异或运算把两个单一游戏连接到一起，作为一个后继状态要是数据范围很大，SG函数就不能用了，有结论 SG\\left( x\\right) =\\begin{cases}x-1\\left( x\\mod4=0\\right) \\\\ x\\left( x\\mod4=1 \\lor 2\\right) \\\\ x+1\\left( x\\mod4=3\\right) \\end{cases}hhhhhhhhhhh 定义根据上面的游戏,定义Multi-SG游戏 Multi-SG 游戏规定，在符合拓扑原则的前提下，一个单一游戏的后继可以为多个单一游戏。 Multi-SG其他规则与SG游戏相同。注意在这里要分清楚后继与多个单一游戏例题HDU 303212345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int maxn=1001;int read() &#123; char c=getchar();int x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int a[maxn],sg[maxn];int main() &#123; int T=read(); while(T--) &#123; int n=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); for(int i=1;i&lt;=n;i++) if(a[i] % 4 == 0) sg[i] = a[i]-1; else if(a[i]%4==1||a[i]%4==2) sg[i] = a[i]; else sg[i] = a[i]+1; int ans=0; for(int i=1;i&lt;=n;i++) ans^=sg[i]; if(ans)puts(\"Alice\"); else puts(\"Bob\"); &#125; return 0;&#125; POJ 2311123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;cstring&gt;const int maxn=3824;int read() &#123; char c=getchar();int x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int sg[maxn][maxn];//当前剩余i行 j列的sg函数 int vis[maxn];int main() &#123; int n=201,m=201; for(int i=2;i&lt;=n;i++) for(int j=2;j&lt;=n;j++) &#123; memset(vis,0,sizeof(vis)); for(int k=2;k&lt;=i-2;k++) vis[sg[k][j]^sg[i-k][j]]=1; for(int k=2;k&lt;=j-2;k++) vis[sg[i][k]^sg[i][j-k]]=1; for(int k=0;;k++) if(!vis[k]) &#123;sg[i][j]=k;break;&#125; &#125; while(scanf(\"%d%d\",&amp;n,&amp;m)!=EOF) puts(sg[n][m] ? \"WIN\" : \"LOSE\"); return 0;&#125; BZOJ 2940 BZOJ 1188 洛谷 3235 Every-SG给定一张无向图，上面有一些棋子，两个顶尖聪明的人在做游戏，每人每次必须将可以移动的棋子进行移动，不能移动的人输 分析这样的话，能赢得游戏必须赢为了赢得最后的胜利当你知道某一个单一游戏一定会输的话，你需要尽力缩短游戏的时间，相反的当你知道某一个游戏一定会赢的话，那么就需要尽力延长游戏的时间 定义: 对于还没有结束的单一游戏，游戏者必须对该 游戏进行一步决策； Every-SG游戏的其他规则与普通 SG游戏相同 Every-SG游戏与普通游戏最大的不同就是他多了一维时间对于SG的值为0,我们需要周到最少走多少步才能结束，对于SG值不为0的点我们需要最多走多少步结束我们用step变量来记录这个步数 step(u) = \\begin{cases} 0, & \\text{$u为终止状态$}\\\\ max\\{step(v)\\}, & \\text{ $sg(u)\\neq 0\\land v为u的后继\\land sg(v)=0$ }\\\\ min\\{step(v)\\}, & \\text{$sg(u)=0\\land v为u的后继$} \\end{cases}定理对于Every-SG游戏先手必胜当且仅当单一游戏中最大的step为奇数。定理是显然的： 对于Every-SG游戏先手必胜当且仅当单一游戏中最大的step为奇数。 定理是显然的：最大的单一游戏步数如果是奇数的话那么肯定是先手取得进行最后一步，否则一定是对手取走最后一个棋子。HDU 3595 GG and MM1balabala//我还没写QUQ","categories":[{"name":"算法笔记","slug":"算法笔记","permalink":"11101001.com/categories/算法笔记/"}],"tags":[{"name":"博弈论与SG函数","slug":"博弈论与SG函数","permalink":"11101001.com/tags/博弈论与SG函数/"},{"name":"博弈论","slug":"博弈论","permalink":"11101001.com/tags/博弈论/"}]},{"title":"bzoj 1005 [HNOI2008]明明的烦恼","slug":"bzoj 1005 [HNOI2008]明明的烦恼","date":"2018-02-21T13:30:29.000Z","updated":"2018-03-10T12:25:10.000Z","comments":true,"path":"2018/02/21/bzoj 1005 [HNOI2008]明明的烦恼/","link":"","permalink":"11101001.com/2018/02/21/bzoj 1005 [HNOI2008]明明的烦恼/","excerpt":"","text":"题目链接:bzoj 1005: [HNOI2008]明明的烦恼 题解:首先要了解prufer序列对于每个prufer序列都对应唯一的一棵树,对于该规定了度数的点也就规定了该店在prufer序列中出现的次数,那么就是求prufer序列的方案数也就是可重复序列的全排列。首先只考虑规定度数得点设其度数为d[i],有k个,那么他在prufer中出现的次数就是d[i]-1设tot=\\sum_i^{k}d[i]-1那么可重排列方案数为 C_{tot}^{d[1]-1}*C_{tot-d[1]-1}^{d[2]-1}*\\ldots C_{d[k]-1}^{d[k]-1}然后在乘上$C_{n-2}^{tot}$选点方案考虑非规定度数点的选取方案对于没有限制的点，直接有 $(n-k)^{n-2-tot}$种可选。答案为无限制与有限制向乘然后，高精，为了不超时，用质数表来优化。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/************************************************************** Problem: 1005 为了不超时，用质数表来优化。 Language: C++ Result: Accepted Time:640 ms Memory:876 kb****************************************************************/#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int prime[1000]=&#123;2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997&#125;;int n,d[1010],s[200],k=0,sum=0,base=10000;struct BigInt &#123; int len,a[10007]; BigInt() &#123; len=1; memset(a,0,sizeof(a));a[0]=1; &#125; int &amp; operator[](int x) &#123; return a[x]; &#125; void print() &#123; printf(\"%d\",a[len-1]); for(int i=len-2;i&gt;=0;i--) printf(\"%04d\",a[i]); puts(\"\"); &#125;&#125;; BigInt operator*(BigInt x,int y) &#123; for(int i=0;i&lt;x.len;i++) x[i]*=y; for(int i=0;i&lt;x.len;i++) x[i+1]+=x[i]/base,x[i]%=base; while(x[x.len]) x[x.len]+=x[x.len-1]/base, x[x.len-1]%=base, x.len++; return x;&#125;void mul(int x,int y)&#123; for(int j=0;j&lt;168;j++)&#123; while(x%prime[j]==0) &#123; x/=prime[j]; s[j]+=y; &#125; &#125;&#125;int main() &#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf(\"%d\",&amp;d[i]); if(d[i]==-1) k++; else sum+=d[i]-1; &#125; if(sum&gt;n-2) &#123; puts(\"0\"); return 0; &#125; for(int i=0;i&lt;sum;i++) mul(n-2-i,1); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;d[i];j++) mul(j,-1); mul(k,n-sum-2); BigInt ans; for(int i=0;i&lt;200;i++) for(int j=0;j&lt;s[i];j++) ans=ans*prime[i]; ans.print(); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"11101001.com/categories/题解/"},{"name":"bzoj","slug":"题解/bzoj","permalink":"11101001.com/categories/题解/bzoj/"}],"tags":[{"name":"数学","slug":"数学","permalink":"11101001.com/tags/数学/"},{"name":"排列组合","slug":"排列组合","permalink":"11101001.com/tags/排列组合/"},{"name":"prufer序","slug":"prufer序","permalink":"11101001.com/tags/prufer序/"}]},{"title":"bzoj 2301 HAOI2011 Problem b","slug":"bzoj 2301 HAOI2011 Problem b","date":"2018-02-21T12:55:29.000Z","updated":"2018-03-10T13:33:50.000Z","comments":true,"path":"2018/02/21/bzoj 2301 HAOI2011 Problem b/","link":"","permalink":"11101001.com/2018/02/21/bzoj 2301 HAOI2011 Problem b/","excerpt":"","text":"题目链接BZOJ 2301 HAOI2011 Problem b 题解\\sum_{i=1}^n\\sum_{j=1}^m[gcd(i,j)==k]=\\sum_{i=1}^{? \\dfrac{n}{k}?}\\sum_{j=1}^{?\\dfrac{m}{k}?}[gcd(i,j)==1]利用函数f(x)表示x|(gcd(i,j))中ij的对数,那么原函数: =\\sum_{i=1}^{? \\dfrac{n}{k}?}\\sum_{j=1}^{?\\dfrac{m}{k}?}\\sum_{d|gcd(i,j)}\\mu(d)=\\sum_{d=1}^{min(\\dfrac{n}{k},\\dfrac{m}{k})} \\mu(d)*\\sum_{d|i,i\\leq\\dfrac{n}{k}}\\sum_{d|j,j\\leq\\dfrac{m}{k}}1\\sum_{d=1}^{min(?\\dfrac{n}{k}?,?\\dfrac{m}{k}?)} \\mu(d)*?\\dfrac{n}{k}?*?\\dfrac{m}{k}?)$?\\dfrac{n}{k}?$最多只有$2\\sqrt{n}$个取值,预处理$\\mu(d)$ $O(\\sqrt{n})$回答 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;typedef long long LL;const int maxn=50007;inline int read() &#123; int x=0; char c=getchar(); while(c&lt;'0'||c&gt;'9')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+c-'0',c=getchar(); return x;&#125;int n,prime[maxn];bool vis[maxn];long long mu[maxn];void get_rj() &#123; mu[1]=1; for(int i=2;i&lt;=maxn-1;i++) &#123; if(!vis[i]) prime[++prime[0]]=i,mu[i]=-1; for(int j=1;j&lt;=prime[0]&amp;&amp;i*prime[j]&lt;=maxn-1;j++) &#123; vis[i*prime[j]]=1; if(i%prime[j]==0) &#123; mu[i*prime[j]]=0;break; &#125; mu[i*prime[j]]=-mu[i]; &#125; &#125; for(int i=1;i&lt;=maxn-1;i++) mu[i]+=mu[i-1];&#125;LL calc(int n,int m,int k) &#123; n/=k;m/=k; if(n&gt;m) std::swap(n,m); LL ans=0;int next=0; for(int i=1;i&lt;=n;i=next+1) &#123; next=std::min(n/(n/i),m/(m/i)); ans+=(mu[next]-mu[i-1])*(n/i)*(m/i); &#125; return ans;&#125;int main() &#123; get_rj(); int T=read(); for(int a,b,c,d,k;T--;) &#123; a=read();b=read();c=read();d=read();k=read(); printf(\"%lld\\n\",calc(b,d,k)-calc(a-1,d,k)-calc(b,c-1,k)+calc(a-1,c-1,k)); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"11101001.com/categories/题解/"},{"name":"bzoj","slug":"题解/bzoj","permalink":"11101001.com/categories/题解/bzoj/"}],"tags":[{"name":"数学","slug":"数学","permalink":"11101001.com/tags/数学/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"11101001.com/tags/莫比乌斯反演/"}]},{"title":"hdu 1425 Happy 2004","slug":"hdu 1425 Happy 2004","date":"2018-02-10T11:12:29.000Z","updated":"2018-02-21T13:39:44.000Z","comments":true,"path":"2018/02/10/hdu 1425 Happy 2004/","link":"","permalink":"11101001.com/2018/02/10/hdu 1425 Happy 2004/","excerpt":"","text":"题目链接hdu 1425 Happy 2004 题解题目大意:求 \\sum_{d|2004^{x}}d mod 29记为$s(2004^x)$ $s(2004^{x})= s(2^2X)) s(3^X) s(167^X)$ $167 \\ mod \\ 29 = 22 $ $s(2004^X) = s(2^{2X}) s(3^{X})) s(22^X)$此时底数变为了质数如果p是素数$s(p^n)=1+p+p^2+…+p^n= (p^{n+1}-1) / (p-1)$上面的式子带下来,写代码就好了对于除法取mod需要求逆元29为素数-&gt;快速幂或者,打个表不就好了嘛233 代码123456789101112131415161718192021222324252627282930#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;inline int read() &#123; int x=0,f=1; char c=getchar(); while(c&lt;'0'||c&gt;'9')c=getchar(); while(c&lt;='9'&amp;&amp;c&gt;='0')x=x*10+c-'0',c=getchar(); return x;&#125;#define mod 29int x,a,b,c;int pow(int a,int p) &#123; int ret=1; for(;p;p&gt;&gt;=1,a=a*a%mod) &#123; if(p&amp;1)ret=ret*a%mod; &#125; return ret;&#125;int main() &#123; while(1) &#123; x=read(); if(!x)break; a=pow(2,2*x+1); b=pow(3,x+1); c=pow(22,x+1); printf(\"%d\\n\",(a-1)*(b-1)*15*(c-1)*18%mod); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"11101001.com/categories/题解/"},{"name":"HDU","slug":"题解/HDU","permalink":"11101001.com/categories/题解/HDU/"}],"tags":[{"name":"数学","slug":"数学","permalink":"11101001.com/tags/数学/"},{"name":"积性函数","slug":"积性函数","permalink":"11101001.com/tags/积性函数/"}]},{"title":"POJ 1286-Necklace of Beads","slug":"POJ 1286-Necklace of Beads","date":"2018-02-09T05:55:29.000Z","updated":"2018-03-10T13:14:18.000Z","comments":true,"path":"2018/02/09/POJ 1286-Necklace of Beads/","link":"","permalink":"11101001.com/2018/02/09/POJ 1286-Necklace of Beads/","excerpt":"","text":"题目链接POJ 1286 Necklace of Beads 题解数据范围,不需要推式子两种置换，旋转与反转对于旋转置换,共有n种置换,跨度为k的置换轮换的个数为gcd(k,n)对与反转置换-&gt;当n为奇数是有种置换,每种置换包含n/2+1种轮换。-&gt;当n是偶数时,如果对称轴过珠子,则存在n/2种置换，每种置换包含n/2种轮换如果对称轴不过珠子,则存在n/2种置换，每种置换包含n/2+1种轮换polay定理 代码123456789101112131415161718192021222324#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using std::__gcd;#define LL long longLL ans;int main() &#123; int n; while(scanf(\"%d\",&amp;n)==1) &#123; if(n==-1) break; if(!n)&#123;puts(\"0\");continue;&#125; ans=0; for(int i=1;i&lt;=n;i++) ans+=pow((LL)3,__gcd(n,i)); if(n&amp;1) ans+=pow(3,(n+1)/2)*n; else &#123; ans+=pow(3,n/2+1)*(n/2); ans+=pow(3,n/2)*(n/2); &#125; printf(\"%lld\\n\",ans/(2*n)); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"11101001.com/categories/题解/"},{"name":"poj","slug":"题解/poj","permalink":"11101001.com/categories/题解/poj/"}],"tags":[{"name":"数学","slug":"数学","permalink":"11101001.com/tags/数学/"},{"name":"Burnside引理与polay定理","slug":"Burnside引理与polay定理","permalink":"11101001.com/tags/Burnside引理与polay定理/"}]},{"title":"luogu P1446 [HNOI2008]Cards","slug":"HNOI2008-Cards","date":"2018-02-09T04:27:29.000Z","updated":"2018-03-10T13:05:56.000Z","comments":true,"path":"2018/02/09/HNOI2008-Cards/","link":"","permalink":"11101001.com/2018/02/09/HNOI2008-Cards/","excerpt":"","text":"题目链接luogu P1446 [HNOI2008]Cards 题解题意就是求染色方案-&gt;等价类洗牌方式构成成了一个置换群然而,染色数限制不能用polay定理直接求解考虑burnside引理对于一个置换群其等价类的个数为置换中不动点的平均数先暴力求出置换中的轮换，然后01背包DP求出不动点方案数 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using std::__gcd;#define LL long longconst int maxn = 70;inline int read() &#123; char c=getchar();int x=0; while(c&lt;'0'||c&gt;'9') c=getchar(); while(c&lt;='9'&amp;&amp;c&gt;='0')x=x*10+c-'0',c=getchar(); return x;&#125;int sr,sb,sg,m,p,n,cnt;bool vis[maxn],size[maxn*maxn];int col[maxn],f[maxn][maxn][maxn];inline void find() &#123;//找到该置换中轮换的个数 cnt=0; memset(vis,0,sizeof vis); memset(size,0,sizeof col); for(int i=1;i&lt;=n;++i) &#123; if(!vis[i]) &#123; int p=i;cnt++; while(!vis[p])vis[p]=1,size[cnt]++,p=col[p]; &#125; &#125;&#125;int count() &#123; memset(f,0,sizeof f); f[0][0][0]=1; for(int q=1;q&lt;=cnt;++q) for(int i=sr;i&gt;=0;--i) for(int j=sb;j&gt;=0;--j) for(int k=sg;k&gt;=0;--k) &#123; if(i&gt;=size[q]) f[i][j][k]=(f[i][j][k]+f[i-size[q]][j][k])%p; if(j&gt;=size[q]) f[i][j][k]=(f[i][j][k]+f[i][j-size[q]][k])%p; if(k&gt;=size[q]) f[i][j][k]=(f[i][j][k]+f[i][j][k-size[q]])%p; &#125; return f[sr][sb][sg];&#125;LL qpow(int x,int q) &#123; int ret=1; for(int i=q;i;i&gt;&gt;=1,x=x*x%p) if(i&amp;1)ret=ret*x%p; return ret;&#125;int main() &#123; LL ans=0; sr=read(),sb=read(),sg=read(),m=read(),p=read(); n=sr+sb+sg; for(int i=1;i&lt;=m;++i) &#123; for(int j=1;j&lt;=n;++j) &#123; col[j]=read(); &#125; find(); ans+=count(); &#125; //m+1为不动置换 for(int i=1;i&lt;=n;++i) col[i]=i; find(); ans+=count(); ans=(ans*qpow(m+1,p-2))%p; std::cout&lt;&lt;ans&lt;&lt;std::endl; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"11101001.com/categories/题解/"},{"name":"luogu","slug":"题解/luogu","permalink":"11101001.com/categories/题解/luogu/"}],"tags":[{"name":"数学","slug":"数学","permalink":"11101001.com/tags/数学/"},{"name":"题解","slug":"题解","permalink":"11101001.com/tags/题解/"},{"name":"Burnside引理与polay定理","slug":"Burnside引理与polay定理","permalink":"11101001.com/tags/Burnside引理与polay定理/"}]},{"title":"POJ 2154 color","slug":"POJ2154color","date":"2018-02-09T04:25:29.000Z","updated":"2018-03-10T12:27:42.000Z","comments":true,"path":"2018/02/09/POJ2154color/","link":"","permalink":"11101001.com/2018/02/09/POJ2154color/","excerpt":"","text":"题目链接POJ 2154 color 题解对于一个n元素环染色,先考虑旋转,置换的总数是n个旋转k个元素后构成的循环数,即轮换数为$gcd(k,n)$根据polay定理,方案数为\\dfrac{1}{n}\\sum_{k=1}^nn^{gcd(k,n)}对与于这个式子可以化为 \\dfrac{1}{n} \\sum_{d|n}n^d\\sum_{k=1}^{n}[gcd(k,n)==d]\\sum_{d|n}n^{d-1}\\sum_{k=1}^{n}[gcd(\\dfrac{k}{d},\\dfrac{n}{d})==1]\\sum_{d|n}n^{d-1}\\sum_{k=1}^{\\dfrac{n}{d}}[gcd(k,\\dfrac{n}{d})==1]\\sum_{d|n}n^{d-1}*\\phi(\\dfrac{n}{d})欧拉+快速幂 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;int n,p;const int maxn = 1000000007;inline int read() &#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9') &#123;if(c=='-')f=-1;c=getchar();&#125; while(c&lt;='9'&amp;&amp;c&gt;='0') x=x*10+c-'0',c=getchar(); return x*f;&#125;const int maxm = 1000005;int pri[maxm],tot=0;bool vis[maxm];int phi(int x) &#123; int ret=x;; for(int i=1;pri[i]&lt;=sqrt(x);i++) if(x%pri[i]==0) &#123; ret=(ret-ret/pri[i]); while(x%pri[i]==0)x/=pri[i]; &#125; if(x!=1)ret=(ret-ret/x); return ret%p;&#125;void getpre() &#123; for(int i=2;i&lt;=1000000;i++) &#123; if(!vis[i])pri[++tot]=i; for(int j=1;j&lt;=tot&amp;&amp;pri[j]*i&lt;=1000000;j++) &#123; vis[pri[j]*i]=1; if(i%pri[j]==0)break; &#125; &#125;&#125;int qpow(int n,int cnt) &#123; int ret=1,tmp=n;tmp%=p; while(cnt) &#123; if(cnt&amp;1) ret=(tmp*ret)%p; tmp=tmp*tmp%p; cnt&gt;&gt;=1; &#125; return ret;&#125;void dec(int n) &#123; int ans=0; for(int i=1;i*i&lt;=n;++i) &#123; if(i*i==n)ans=(ans+phi(i)*qpow(n,i-1))%p; else if(!(n%i)) &#123; ans=(ans+qpow(n,i-1)*phi(n/i)+qpow(n,n/i-1)*phi(i))%p; &#125; &#125; printf(\"%d\\n\",ans);&#125;int main() &#123; getpre(); int cnt=read();// for(int i=1;i&lt;=cnt;++i) &#123;// printf(\"%d \",phi[i]);// &#125; for(;cnt--;) &#123; n=read(),p=read(); dec(n); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"11101001.com/categories/题解/"},{"name":"poj","slug":"题解/poj","permalink":"11101001.com/categories/题解/poj/"}],"tags":[{"name":"数学","slug":"数学","permalink":"11101001.com/tags/数学/"},{"name":"题解","slug":"题解","permalink":"11101001.com/tags/题解/"},{"name":"Burnside引理与polay定理","slug":"Burnside引理与polay定理","permalink":"11101001.com/tags/Burnside引理与polay定理/"}]},{"title":"Burnside引理与polay定理","slug":"Burnside与paloy定理","date":"2018-02-07T13:59:59.000Z","updated":"2018-02-09T14:00:26.000Z","comments":true,"path":"2018/02/07/Burnside与paloy定理/","link":"","permalink":"11101001.com/2018/02/07/Burnside与paloy定理/","excerpt":"","text":"Burnside引理与polay定理引入概念1.置换简单来说就是最元素进行重排列是所有元素的异议映射，即$[1,n]$映射到$[1,n]$ \\begin{pmatrix} 1&2&i \\ldots n \\\\ a_{1} & a_{2}&a_{i} \\ldots a_{n} \\end{pmatrix}比如,把正方体绕中心旋转90度，可以看做四个顶点的一个置换(1)置换可以构成换:对于元素连一条有向边，连到置换中映射的元素，会构成n个环,(循环)(2)如果一个状态$S$经过置换后与原来相同，即S[1]=S[a_1],S[2]=S[a_2] \\ldots S[n]=S[a_n]那么称这个状态$S$为不动点(3)本质不同的方案数一般指方案类的种数,等价关系通常是一个置换集合,如果一个置换能把其中一个方案映射到另一个方案那么他么是等价的。置换构成的置换群就是交换排列顺序而已。 2Brunside对于一个置换群$G$,$G$是目标集[1,n]上的置换群,若一个染色方案$S$经过置换后不变,称$S$为G的不动点。将不动点的数目记为$C(G)$则等价类$l$的数目为$C(G)$的平均值 l=\\dfrac {1}{\\left| G\\right| }[c_1(a_1)+c1(a_2)+ \\ldots +c_1(a_g)]证明明的话,泥萌还是去看抽象数学吧QAQ百度百科给了证明证明1：$g\\in G$,记$X_g(x)=1$表示$g(x)=x$否则$X_g(x)=0$。考虑以下和式：对于上式最右边我们有：所以： 例子一个正方形分成4格,着上两种颜色,有多少种方案?其中经过转动相同图像的算一种方案根据计数原理,每个格子都有两种颜色可选所以，一共有16种图像对于图中图像的置换可分为以下四种不动: a_1=(1)(2)\\ldots (16)逆时针旋转90度 a_2=(1)(2)(3\\ 4\\ 5 6)(7\\ 8\\ 9\\ 10) (11\\ 12)(13\\ 14\\ 15\\ 16)顺时针旋转90度 a_3=(1)(2)(6\\ 5\\ 4\\ 3)(10\\ 9\\ 8\\ 7)(11\\ 12)(16\\ 15\\ 14\\ 13)旋转180度 a_4=(1)(2)(3\\ 5)(4\\ 6)(7\\ 9)(8\\ 10)(11)(12) (13\\ 15)(14\\ 16)那么有Burnside引理可知第一种情况不动点种类为16(全)种第二种情况不动点种类为$(1)\\ (2)$2种第三种情况与第二种情况相同第四种情况为$(1)\\ (2) \\ (11)\\ (12)$4种那么有Burnside引理可知等价类的种类为(16+2+2+4)/4=6种 例题:POJ 2154 3Polya定理利用Burnside引理要首先列出所有$n^m$种可能的染色方案然后找出在每个置换下保持不变的方案数,显然当m或n很大的时候,复杂度会炸,这时就需要用到polya定理。Polya定理实际上是Burnside引理的具体化，提供了计算不动点的具体方法。假设一个置换有$\\sigma_k$个循环易知每个循环对应的所有位置颜色需一致，而任意两个循环之间选什么颜色互不影响。因此，如果有m种可选颜色，则该置换对应的不动点个数为$m^{\\sigma_k}$。用其替换Burnside引理中的$C(G)$，即$C(G)=m^k$。得到等价类数目为： M=\\dfrac {1}{\\left| G\\right| }\\sum ^{|G|}_{k=1}m^{c (\\sigma _{k})}$|G|$表示置换的数目$\\sigma _k$表示第k个置换包含的循环数目 例子 仍然是一个正方形分成4格,着上两种颜色那么对于一种定点而言当不动：$a_1=(1)(2)(3)(4)$ //单个旋转90度 ：$a_2=(1\\ 2\\ 3\\ 4)$ //全涂旋转180度 ：$a_3=(1\\ 3)(2\\ 4)$ //单排旋转270度：$a_4=(1\\ 4\\ 3\\ 2)$ //对角线那么$M=\\dfrac {1}{4} * (2^4+2^1+2^2+2^1)=6$ 例题POJ1286完","categories":[{"name":"算法笔记","slug":"算法笔记","permalink":"11101001.com/categories/算法笔记/"}],"tags":[{"name":"数学","slug":"数学","permalink":"11101001.com/tags/数学/"},{"name":"Burnside引理与polay定理","slug":"Burnside引理与polay定理","permalink":"11101001.com/tags/Burnside引理与polay定理/"}]},{"title":"Mathjax测试","slug":"latex测试","date":"2018-02-03T00:55:29.000Z","updated":"2018-02-09T09:07:20.000Z","comments":true,"path":"2018/02/03/latex测试/","link":"","permalink":"11101001.com/2018/02/03/latex测试/","excerpt":"","text":"\\begin{align} \\dot{x} & = \\sigma(y-x) \\\\ \\dot{y} & = \\rho x - y - xz \\\\ \\dot{z} & = -\\beta z + xy F_{\\mu} F_a + F_b = F_c \\end{align}","categories":[{"name":"测试","slug":"测试","permalink":"11101001.com/categories/测试/"}],"tags":[{"name":"测试","slug":"测试","permalink":"11101001.com/tags/测试/"}]},{"title":"bzoj 2190 [SDOI2008]仪仗队","slug":"bzoj 2190 [SDOI2008]仪仗队","date":"2018-02-02T13:55:29.000Z","updated":"2018-03-10T12:24:50.000Z","comments":true,"path":"2018/02/02/bzoj 2190 [SDOI2008]仪仗队/","link":"","permalink":"11101001.com/2018/02/02/bzoj 2190 [SDOI2008]仪仗队/","excerpt":"","text":"bzoj 2190 显然 以C菌为原点构建坐标系 当横纵坐标(a,b)不互质时,斜率a/b与a/gcd(a,b)和b/gcd(a,b)斜率相等,那么一定会被(a/gcd(a,b),b/gcd(a,b))挡住 那就是求$\\sum_{i=1}^{n}\\sum_{j=1}^{n} gcd(i,j)=1$ 求个欧拉就好了QAQ 线性求欧拉$O(n)$12345678910111213141516171819202122232425#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;int n;const int maxn =400004;int phi[maxn];void get_phi() &#123; phi[1]=1; for(int i=2; i&lt;=n; i++) &#123; if(!phi[i]) for(int j=i; j&lt;=n; j+=i) &#123; if(!phi[j])phi[j]=j; phi[j]=phi[j]/i*(i-1); &#125; &#125;&#125;int main() &#123; scanf(&quot;%d&quot;,&amp;n); get_phi(); int ans=0; for(int i=1; i&lt;=n-1; i++)ans+=phi[i]; printf(&quot;%d&quot;,2*ans+1); return 0;&#125; 单个求欧拉12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;using namespace std;const int maxn = 1110101;int oula[maxn];int prime[maxn];bool a[maxn];int n;int phi(int x) &#123; int ret=1; for(int i=2;i*i&lt;=x;i++) &#123; if(x%i==0) &#123; ret*=i-1,x/=i; while(x%i==0) &#123; ret*=i;x/=i; &#125; &#125; &#125; if(x&gt;1)ret*=x-1; return ret;&#125;int main () &#123; scanf(\"%d\",&amp;n); int ans=0; for(int i=1;i&lt;n;i++) &#123; ans+=phi(i); &#125; ans=ans*2,ans+=1; printf(\"%d\\n\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"11101001.com/categories/题解/"},{"name":"bzoj","slug":"题解/bzoj","permalink":"11101001.com/categories/题解/bzoj/"}],"tags":[{"name":"数学","slug":"数学","permalink":"11101001.com/tags/数学/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"11101001.com/tags/欧拉函数/"}]},{"title":"bzoj 1924 [Sdoi2010]所驼门王的宝藏","slug":"bzoj 1924 [Sdoi2010]所驼门王的宝藏","date":"2018-02-02T10:55:29.000Z","updated":"2018-03-10T13:06:18.000Z","comments":true,"path":"2018/02/02/bzoj 1924 [Sdoi2010]所驼门王的宝藏/","link":"","permalink":"11101001.com/2018/02/02/bzoj 1924 [Sdoi2010]所驼门王的宝藏/","excerpt":"","text":"bzoj1924 tarjan后dp常规操作求最长路 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#define LL long longconst int maxn = 5000007;inline int read()&#123; int x=0,f=1; char c=getchar(); while(c&lt;'0' || c&gt;'9') &#123;if (c=='-') f=-1; c=getchar();&#125; while(c&gt;='0' &amp;&amp; c&lt;='9') &#123;x=x*10+c-'0'; c=getchar();&#125; return x*f;&#125;struct data&#123; int x,y,id,opt;&#125;a[maxn];struct edge&#123; int to,next;&#125;edge[maxn&lt;&lt;2],E[maxn];int head[maxn],H[maxn&gt;&gt;1],cnt,recnt,ind,top,n,x,y;bool inq[maxn],vis[maxn&gt;&gt;1];int ans; int q[maxn],dfn[maxn],low[maxn];int size[maxn&gt;&gt;1],belong[maxn],tot;bool cmp_x(data a,data b) &#123; return a.x&lt;b.x;&#125;bool cmp_y(data a,data b) &#123; return a.y&lt;b.y;&#125;void add_edge(int x, int y) &#123; edge[++cnt].to=y; edge[cnt].next=head[x]; head[x]=cnt;&#125;void Add_edge(int x, int y) &#123; E[++recnt].to=y; E[recnt].next=H[x]; H[x]=recnt;&#125;void tarjan(int x) &#123; q[++top]=x; dfn[x]=low[x]=++ind; inq[x]=1; for(int i=head[x];i;i=edge[i].next) if(!dfn[edge[i].to]) &#123; tarjan(edge[i].to); low[x]=std::min(low[x],low[edge[i].to]); &#125; else if (inq[edge[i].to]) low[x]=std::min(low[x],dfn[edge[i].to]); int now=-1; if(dfn[x]==low[x]) &#123; tot++; while(now!=x) &#123; now=q[top--]; belong[now]=tot; size[tot]++; inq[now]=0; &#125; &#125;&#125;void dfs(int x) &#123; vis[x]=1;int mx=0; for(int i=H[x];i;i=E[i].next)&#123; if(!vis[E[i].to]) dfs(E[i].to); mx=std::max(size[E[i].to],mx); &#125; ans=std::max(ans,size[x]+=mx);&#125;std::map&lt;LL,int&gt;GG;int main() &#123; n=read();x=read();y=read(); for (int i=1; i&lt;=n; i++) a[i].x=read(), a[i].y=read(),a[i].opt=read(),GG[(LL)a[i].x*maxn+a[i].y]=i,a[i].id=i; std::sort(a+1,a+n+1,cmp_x); for(int i=1;i&lt;=n;i++) if(a[i].opt==1) &#123; for (int j=i-1;j&gt;=1; j--) if (a[i].x==a[j].x) add_edge(a[i].id,a[j].id); else break; for (int j=i+1; j&lt;=n; j++) if (a[i].x==a[j].x) add_edge(a[i].id,a[j].id); else break; &#125; std::sort(a+1,a+n+1,cmp_y); for(int i=1;i&lt;=n;i++) if(a[i].opt==2) &#123; for(int j=i-1;j&gt;=1;j--) if(a[i].y==a[j].y) add_edge(a[i].id,a[j].id); else break; for(int j=i+1;j&lt;=n;j++) if(a[i].y==a[j].y) add_edge(a[i].id,a[j].id); else break; &#125; for(int i=1;i&lt;=n;i++) if(a[i].opt==3)&#123; for(int j=a[i].x-1; j&lt;=a[i].x+1; j++) for(int k=a[i].y-1; k&lt;=a[i].y+1; k++) if(j!=a[i].x||k!=a[i].y) if(GG[(LL)j*maxn+k]) add_edge(a[i].id,GG[(LL)j*maxn+k]); &#125; for(int i=1; i&lt;=n; i++) if(!dfn[i])tarjan(i); for(int x=1;x&lt;=n;x++) for(int i=head[x];i;i=edge[i].next) if(belong[x]!=belong[edge[i].to]) Add_edge(belong[x],belong[edge[i].to]); for(int i=1;i&lt;=tot;i++) if(!vis[i]) dfs(i); printf(\"%d\\n\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"11101001.com/categories/题解/"},{"name":"bzoj","slug":"题解/bzoj","permalink":"11101001.com/categories/题解/bzoj/"}],"tags":[{"name":"tarjan","slug":"tarjan","permalink":"11101001.com/tags/tarjan/"},{"name":"动态规划","slug":"动态规划","permalink":"11101001.com/tags/动态规划/"}]},{"title":"markdown测试与UOJ#218","slug":"2018_2_2","date":"2018-02-01T10:55:29.000Z","updated":"2018-03-10T12:25:36.000Z","comments":true,"path":"2018/02/01/2018_2_2/","link":"","permalink":"11101001.com/2018/02/01/2018_2_2/","excerpt":"","text":"UOJ传送门 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题 公 式 测 试 $\\sum_{i=1}^{n} a_i^2x_i$$\\prod_{i=1}^{n} a_i^2x_i$另外这是 UOJ #218的题解维护一颗主席树火车入栈相当于区间修改，弹栈相当于返回历史版本维护线段树区间求和extra RE啦卡卡内存应该可过，算啦不写了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;const int maxn = 600005;const int maxm = 40000007;int tt[maxm],ls[maxm],tag[maxm],rs[maxm];int tg[maxn&lt;&lt;2],sum[maxn&lt;&lt;2],sz,rt[maxn&lt;&lt;1],a[maxn&lt;&lt;1];int n,m,ty;int read()&#123; int t=0,f=1;char c=getchar(); while (c&lt;'0'||c&gt;'9')&#123;if(c=='-') f=-1;c=getchar();&#125; while ('0'&lt;=c&amp;&amp;c&lt;='9')&#123;t=t*10+c-'0';c=getchar();&#125; return t*f;&#125;void merge(int k) &#123; if (tag[k]==-1) return; if (!ls[k]) ls[k]=++sz; if (!rs[k]) rs[k]=++sz; tag[ls[k]]=tag[rs[k]]=tt[ls[k]]=tt[rs[k]]=tag[k]; tag[k]=-1;&#125;void modify(int &amp;k,int l,int r,int rt,int tl,int tr,int v)&#123; k=++sz;tag[k]=-1; if (tl&lt;=l&amp;&amp;tr&gt;=r)&#123; tag[k]=tt[k]=v; return; &#125; merge(rt); int mid=(l+r)&gt;&gt;1; ls[k]=ls[rt];rs[k]=rs[rt]; if(mid&gt;=tl)modify(ls[k],l,mid,ls[rt],tl,tr,v); if(mid&lt;tr)modify(rs[k],mid+1,r,rs[rt],tl,tr,v);&#125;int query(int l,int r,int rt,int pos)&#123; if(!rt||l==r) return tt[rt]; merge(rt); int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) return query(l,mid,ls[rt],pos); else return query(mid+1,r,rs[rt],pos);&#125;void pushdown(int l,int r,int rt)&#123; if(tg[rt]==-1||l==r) return; tg[rt&lt;&lt;1]=tg[rt&lt;&lt;1|1]=tg[rt]; int mid=(l+r)&gt;&gt;1; sum[rt&lt;&lt;1]=tg[rt]*(mid-l+1); sum[rt&lt;&lt;1|1]=tg[rt]*(r-mid); tg[rt]=-1;&#125;void modify2(int l,int r,int rt,int tl,int tr,int v)&#123; pushdown(l,r,rt); if(tl&lt;=l&amp;&amp;tr&gt;=r)&#123; tg[rt]=v;sum[rt]=(r-l+1)*v; pushdown(l,r,rt); return; &#125; int mid=(l+r)&gt;&gt;1; if(mid&gt;=tl)modify2(l,mid,rt&lt;&lt;1,tl,tr,v); if(mid&lt;tr)modify2(mid+1,r,rt&lt;&lt;1|1,tl,tr,v); sum[rt]=sum[rt&lt;&lt;1]+sum[rt&lt;&lt;1|1]; &#125;int getsum(int l,int r,int rt,int tl,int tr)&#123; pushdown(l,r,rt); if(tl&lt;=l&amp;&amp;tr&gt;=r)&#123; return sum[rt]; &#125; int mid=(l+r)&gt;&gt;1; int ret=0; if(mid&gt;=tl)ret+=getsum(l,mid,rt&lt;&lt;1,tl,tr); if(tr&gt;mid)ret+=getsum(mid+1,r,rt&lt;&lt;1|1,tl,tr); return ret;&#125;int main()&#123; n=read();m=read();ty=read(); int ans=0; for(int i=1;i&lt;=m;i++)&#123; rt[i]=rt[i-1]; int opt=read(),l=read();l=(l+ty*ans)%n+1; if (opt==1) &#123; int r=read();r=(r+ty*ans)%n+1; if (l&gt;r) std::swap(l,r); printf(\"%d\\n\",ans=getsum(1,n,1,l,r)); &#125; else if (opt==2)&#123; int x=query(1,n,rt[i],l); if(x)&#123; int y=query(1,n,rt[x-1],l); modify(rt[i],1,n,rt[i],l,l,y); modify2(1,n,1,l,l,a[y]); &#125; continue; &#125; else&#123; int r=read();r=(r+ty*ans)%n+1; if (l&gt;r) std::swap(l,r); a[i]=read(); modify(rt[i],1,n,rt[i],l,r,i); modify2(1,n,1,l,r,a[i]); &#125; &#125; return 0;&#125;","categories":[{"name":"大ZZ的日常","slug":"大ZZ的日常","permalink":"11101001.com/categories/大ZZ的日常/"},{"name":"可持久化线段树","slug":"大ZZ的日常/可持久化线段树","permalink":"11101001.com/categories/大ZZ的日常/可持久化线段树/"}],"tags":[{"name":"测试","slug":"测试","permalink":"11101001.com/tags/测试/"}]},{"title":"My Frist Passage","slug":"My-New-Passage","date":"2017-11-07T00:55:29.000Z","updated":"2018-02-09T08:54:12.000Z","comments":true,"path":"2017/11/07/My-New-Passage/","link":"","permalink":"11101001.com/2017/11/07/My-New-Passage/","excerpt":"","text":"HelloGood Night","categories":[{"name":"大ZZ的日常","slug":"大ZZ的日常","permalink":"11101001.com/categories/大ZZ的日常/"}],"tags":[{"name":"233","slug":"233","permalink":"11101001.com/tags/233/"},{"name":"11101001","slug":"11101001","permalink":"11101001.com/tags/11101001/"},{"name":"RT","slug":"RT","permalink":"11101001.com/tags/RT/"}]},{"title":"Hello World","slug":"hello-world","date":"2014-11-07T00:55:29.000Z","updated":"2018-02-03T00:35:52.000Z","comments":true,"path":"2014/11/07/hello-world/","link":"","permalink":"11101001.com/2014/11/07/hello-world/","excerpt":"","text":"本版本仅适用于Win环境本文关键字： Hexo绿色版，Hexo便携版，Hexo配置，Hexo，U盘 Hexo是一个快速、简洁且高效的博客框架，支持 GitHub Flavored Markdown 的所有功能；具有超快生成速度，让上百个页面在几秒内瞬间完成渲染；还拥有各式各样的插件等等。 但是就像很多教程里面写的那样，搭建 Hexo 本地环境，需要安装 Node.js、Git 以及使用 npm 进行安装和配置。这对于毫无经验的新手来说，是一个很大的挑战。同时，由于这些环境的存在，导致如果需要更换计算机的时候，重新安装配置一个新的Hexo环境，又得花费一些功夫。 所以呢，锵锵，我们整合了一个 Hexo 便携版，来简化本地环境的部署。 版本介绍那么所谓的便携版到底是什么？便携版就是将 Hexo 本地环境所需要的各种依赖环境的整合到一起，做成的不需要安装的版本。 本便携版（Release 1.0.0）所包含的软件如下： Git: 2.7.4 Nodejs: 6.10.1 Npm: 4.4.1 Hexo: 3.2.2 为了便携的需要，不能配置固定的环境变量，所以除此之外还有相应的批处理文件，下文将详细介绍。 从零开始，1分钟搭建Hexo写作环境说了这么多，我们这就开始教你如何在1分钟内，从零开始搭建Hexo写作环境！ 1 注册一个Github帐号1.1 进入Github，并在右边的3个框框中分别填写 用户名、邮箱地址、账户密码，并点击 Sign up for Github; 1.2 进入欢迎页面后，点击Finish sign up; 1.3 进入到这一步之后（图1.3.1），先别记着点任何东西，查看你的邮箱，应该会收到如下的邮件（图1.3.2），确认你的邮件。否则，你会看到错误页面（图1.3.3）。query完毕之后在图1.3.1所示的页面，点击+ New repository; 1.4 请在红框中的 Repository name 里面输入 用户名.github.io ( 用户名 就是你刚刚 步骤1.1 中注册的用户名)，然后点击 Create repository; 1.5 至此，Github网页注册的部分完毕 2 下载HEXO Portable2.1 访问我们的 HEXO Portable 页面，或者 Github仓库 下载最新的便携版； 2.2 双击得到的自解压文件，解压到你需要安装博客的地方，可以选择硬盘或者U盘； 3 配置你的环境3.1 在你的博客的文件夹，你会发现很多批处理文件，我先介绍下各个文件的用途： 配置基本信息 &gt;&gt; 配置博客的基本环境 配置Github部署 &gt;&gt; 配置博客的部署 启动命令行 &gt;&gt; 启动带环境变量的Git-Bash，否则无法使用node、npm、git等命令 新建文章 &gt;&gt; 新建一篇文章 渲染并本地测试 &gt;&gt; 生成并本地预览 渲染并部署 &gt;&gt; 生成并部署到GitHub 重置配置文件 &gt;&gt; 重置_config.yml 3.2 我们继续进行环境配置，双击配置基本信息并按顺序输入以下信息： 主标题：顾名思义 副标题：顾名思义 描述：顾名思义 作者：顾名思义 网站地址：填写 用户名.github.io （此处的用户名为步骤1.1中填写的用户名）如果您已经购买了域名，可以参看相关的文章！ 3.3 双击配置Github部署并按顺序输入以下信息： Github的用户名：此处的用户名为步骤1.1中填写的用户名 Github注册邮箱：此处的注册邮箱为步骤1.1中填写的注册邮箱 3.4 输入完毕之后，会进行测试部署，等待屏幕提示下面将进行部署测试，稍后将有一个openssh的对话框出现，请输入你的github用户密码。的时候，按回车继续；（此处的用户密码为步骤1.1中填写的用户密码） 3.5 然后继续等待，此时屏幕会出现n多行，耐心等待即可； 3.6 等待屏幕提示请访问 https://用户名.github.io 查看是否部署成功！的时候，在浏览器中输入https://用户名.github.io ，理论上可以看到你的Hexo站点！（此处的用户名为步骤1.1中填写的用户名） 3.7 至此，你的Hexo环境就配置完成了，这样你的这个Hexo博客文件夹无论移动到哪一台电脑，都能通过启动命令行出现的bash命令行，或者其余便捷的批处理文件比如新建文章、渲染并本地测试、渲染并部署进行相应的操作。 3.8 如果你在配置中出错，可以运行重置配置文件后，再重复3.1~3.6步骤 4 开始享受纯粹的Hexo写作吧！5 备注 本便携版以及本文均使用 CC BY-NC-SA 4.0协议； 本文所有权归 QistChan &amp; Bitmoe Inc. 所有； 本便携版由 Bitmoe Inc. 维护并提供技术支持； 需要技术支持可以在Github仓库 提交Issues； Written with StackEdit.","categories":[],"tags":[]}]}